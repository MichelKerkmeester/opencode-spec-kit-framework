# ─────────────────────────────────────────────────────────────────
# SMART SPECKIT: DEBUG DELEGATION WORKFLOW (AUTONOMOUS MODE)
# ─────────────────────────────────────────────────────────────────
role: Expert Developer using Debug Delegation for Persistent Issues
purpose: Delegate debugging to fresh sub-agent with complete context handoff
action: Run 5-step debug workflow from context validation through integration

# ─────────────────────────────────────────────────────────────────
# OPERATING MODE
# ─────────────────────────────────────────────────────────────────
operating_mode:
  workflow: sequential_5_step
  compliance: MANDATORY
  execution: autonomous
  approvals: none
  tracking: debug_report_creation
  validation: sub_agent_response_check

# ─────────────────────────────────────────────────────────────────
# DEBUG PHILOSOPHY
# ─────────────────────────────────────────────────────────────────
debug_philosophy:
  principle: "Fresh perspective solves stuck problems"
  approach: "Systematic escalation with context preservation"

# ─────────────────────────────────────────────────────────────────
# USER INPUTS
# ─────────────────────────────────────────────────────────────────
user_inputs:
  spec_path: "[SPEC_PATH] - Spec folder path containing the issue. REQUIRED."
  error_message: "[ERROR_MESSAGE] - Error message or symptoms to debug. REQUIRED."
  detection_method: "[DETECTION_METHOD] - How issue was found (recent/provided/ad-hoc). Leave empty to auto-detect."
  affected_files: "[AFFECTED_FILES] - Files involved in the error. Leave empty to infer."
  previous_attempts: "[PREVIOUS_ATTEMPTS] - Prior fix attempts. Leave empty for first delegation."

# ─────────────────────────────────────────────────────────────────
# FIELD HANDLING
# ─────────────────────────────────────────────────────────────────
field_handling:
  defaults: { affected_files_empty: "Infer from error message and conversation", previous_attempts_empty: "Document as 'First delegation attempt'" }
  validation: { spec_path_required: true, error_message_required: true }

# ─────────────────────────────────────────────────────────────────
# CONTEXT LOADING
# ─────────────────────────────────────────────────────────────────
context_loading:
  trigger: "At workflow START, before Step 1"
  mcp_integration:
    tool: memory_search
    note: "Call MCP tools directly - NEVER through Code Mode"
    parameters: { query: "debug context for {spec_folder_name}", specFolder: "{spec_folder_path}", anchors: ['summary', 'decisions', 'state', 'debug'] }
  command_reference: "/memory:context"
  when_to_skip: ["Ad-hoc debugging (no spec folder context)", "Fresh debugging session with no prior attempts"]
  behavior: { if_context_found: "Surface debugging history and decisions before proceeding", if_no_context: "Proceed to Step 1 without delay" }

# ─────────────────────────────────────────────────────────────────
# AVAILABLE TEMPLATES
# ─────────────────────────────────────────────────────────────────
available_templates:
  debug_delegation: .opencode/skill/system-spec-kit/templates/debug-delegation.md
  universal_debugging: .opencode/skill/system-spec-kit/references/debugging/universal_debugging_methodology.md

# ─── AGENT AVAILABILITY (conditional — not instructions) ──────────
# These entries define WHICH agent to use IF a workflow step calls for it.
# Do NOT dispatch agents based on reading this section.
# Agents are activated ONLY when their designated step is executing.
agent_availability:
  speckit:
    available_at_step: 2
    condition: "ONLY dispatch when Step 2 is actively executing to create debug-delegation.md"
    agent_file: ".opencode/agent/speckit.md"
    purpose: "debug-delegation.md is spec folder documentation"
    fallback: "general"
    not_for: "reviewing this workflow, pre-step activity, or any other documentation"
  review:
    available_at_step: 5
    condition: "ONLY dispatch when Step 5 is actively executing AND user chose Option A (Apply fix)"
    agent_file: ".opencode/agent/review.md"
    purpose: "Post-fix code quality validation"
    fallback: "general"
    blocking: false
    advisory: true
    not_for: "reviewing this workflow prompt, pre-step validation, or reviewing the debug process itself"

# ─────────────────────────────────────────────────────────────────
# MULTI-AGENT DISPATCH CONFIGURATION
# ─────────────────────────────────────────────────────────────────
multi_agent_config:
  enabled: true
  dispatch_modes:
    single: { id: A, label: "Single Agent", agents: 1, model: opus }
    multi_small:
      id: B
      label: "Multi-Agent (1+2)"
      orchestrator: { model: opus, role: coordinator }
      workers:
        - { role: call_path_tracer, focus: "Execution Path Analysis", phase: ANALYZE }
        - { role: pattern_searcher, focus: "Similar Working Code", phase: ANALYZE }
    multi_large:
      id: C
      label: "Multi-Agent (1+3)"
      orchestrator: { model: opus, role: coordinator }
      workers:
        - { role: call_path_tracer, focus: "Execution Path Analysis", phase: ANALYZE }
        - { role: pattern_searcher, focus: "Similar Working Code", phase: ANALYZE }
        - { role: edge_case_hunter, focus: "Boundary Conditions", phase: HYPOTHESIZE }
  fallback: { timeout_s: 60, on_timeout: "continue with available", on_all_fail: "single-agent mode" }

# ─────────────────────────────────────────────────────────────────
# WORKFLOW ENFORCEMENT
# ─────────────────────────────────────────────────────────────────
workflow_enforcement:
  mode: strict
  step_order: sequential_mandatory
  skip_allowed: false
  step_completion_rule: "FOR EACH STEP: Execute ALL activities → Verify ALL outputs → Mark complete → Proceed. NEVER skip a step. NEVER dispatch without debug-delegation.md."
  critical_steps:
    step_2_generate_report: { enforcement: "MUST create debug-delegation.md before dispatch", verification: "File exists in spec folder or scratch/" }
    step_5_integration: { enforcement: "MUST check Gate 3 before applying fixes in ad-hoc mode" }

# ─────────────────────────────────────────────────────────────────
# WORKFLOW
# ─────────────────────────────────────────────────────────────────
workflow:
  step_1_validate_context:
    purpose: Confirm all required context is available from phases
    activities:
      - Verify spec_path exists and is accessible
      - Verify error_message, affected_files, previous_attempts captured
      - Note reproduction_steps (optional but helpful)
    if_context_missing: { action: "Report what's missing and return to Phase 1" }
    outputs: [context_confirmed]
    validation: all_required_context_available

  step_2_generate_report:
    purpose: Create debug-delegation.md using template
    agent: "@speckit"
    template: .opencode/skill/system-spec-kit/templates/debug-delegation.md
    activities:
      - Read template, fill all placeholders with phase outputs
      - Generate task_id as debug-YYYYMMDD-HHMM
      - Classify error_category, document previous_attempts, add root cause hypothesis
      - Save to spec folder or scratch/
    error_categories: { syntax_error: "Parse errors, tokens", type_error: "Type mismatch, TS errors", runtime_error: "Exceptions, crashes", test_failure: "Assertion failures, timeouts", build_error: "Compilation, bundling", lint_error: "Linter, style violations", unknown: "Cannot classify" }
    save_location: { with_spec: "[spec_path]/debug-delegation.md", ad_hoc: "scratch/debug-delegation.md" }
    output: debug_delegation_md path
    validation: file_created_successfully

  step_3_dispatch_subagent:
    purpose: Dispatch @debug agent with structured handoff via Task tool
    agent: "@debug"
    agent_file: ".opencode/agent/debug.md"
    task_parameters: { description: "Debug: [brief error summary - max 50 chars]", subagent_type: "debug", prompt: "[sub_agent_prompt_template]" }
    # REFERENCE ONLY — routing metadata, do not dispatch agents from these values
    sub_agent_prompt_template: |
      # Debug Agent Dispatch

      You are the @debug agent. Execute your 4-phase debugging methodology:
      OBSERVE → ANALYZE → HYPOTHESIZE → FIX

      ## Debug Context Handoff

      ### Error Description
      {error_message}

      ### Files Involved
      {affected_files}

      ### Reproduction Steps
      {reproduction_steps}

      ### Prior Attempts (What Was Tried)
      {previous_attempts}

      ### Environment
      - Spec Folder: {spec_path}

      ## Instructions
      - Follow your 4-phase methodology exactly
      - Form 2-3 ranked hypotheses with evidence
      - Make minimal, targeted fixes
      - Return structured response (Success/Blocked/Escalation format)

      ## Full Debug Report
      {debug_delegation_md_content}
    fallback: { subagent_type: "general-purpose", fallback_reason: "If @debug agent file unavailable or dispatch fails" }
    timeout_ms: 120000
    output: sub_agent_dispatched
    validation: task_tool_invoked

  step_4_receive_findings:
    purpose: Capture and validate sub-agent response
    activities:
      - Wait for sub-agent response
      - Extract root_cause, proposed_fix, verification_steps, prevention
      - Validate proposed_fix includes file paths and executable code
    if_response_received:
      extract: [root_cause, proposed_fix, verification_steps, prevention, caveats]
      validate: "proposed_fix includes file paths and executable code"
    if_timeout_or_error: { action: "Offer retry options (A/B/C)" }
    if_needs_more_context: { action: "Gather additional context and re-dispatch" }
    retry_limit: 3
    outputs: [findings_received, root_cause, proposed_fix]
    validation: valid_findings_captured

  step_5_integration:
    purpose: Present findings and apply resolution
    activities:
      - Display findings summary, present integration options (A/B/C/D)
      - Handle user selection, apply fix if requested (with Gate 3 check)
      - Update debug-delegation.md with resolution
    integration_options:
      A_apply_fix: { label: "Apply the fix", gate_3_check: "IF ad-hoc: Ask spec folder question", actions: [make_code_changes, verify_changes, suggest_tests, update_report], status: "RESOLVED" }
      B_show_details: { label: "Show full details", actions: [display_full_response, re_ask_for_action] }
      C_more_investigation: { label: "Request more investigation", actions: [ask_focus_area, re_dispatch_subagent] }
      D_manual_review: { label: "Manual review", actions: [confirm_user_handles, keep_report], status: "NEEDS_REVIEW" }
    resolution_section: |
      ## 6. RESOLUTION
      **Resolved By:** Sub-agent delegation
      **Resolution Date:** [timestamp]
      **Root Cause:** [from sub-agent]
      **Fix Applied:** [description]
      **Verified:** [yes/no + method]
    outputs: [resolution_complete, status]
    validation: user_action_completed

# ─────────────────────────────────────────────────────────────────
# WORKFLOW TERMINATION
# ─────────────────────────────────────────────────────────────────
termination:
  after_step: 5
  message: "Debug delegation completed."
  next_steps:
    - { condition: "Fix applied successfully", action: "Verify in browser/tests" }
    - { condition: "Fix applied, continue work", action: "Return to original workflow" }
    - { condition: "Issue needs more analysis", action: "/spec_kit:debug (retry with different model)" }
    - { condition: "Want to save debugging context", action: "/memory:save [spec-folder-path]" }
    - { condition: "Debugging session complete", action: "/spec_kit:handover [spec-folder-path]" }
  always_end_with: "What would you like to do next?"

# ─────────────────────────────────────────────────────────────────
# AUTONOMOUS EXECUTION GUIDANCE
# ─────────────────────────────────────────────────────────────────
autonomous_execution:
  principle: "Execute debug delegation with minimal user interaction after phases complete"
  decision_making: [Gather full context, Generate comprehensive debug report, Dispatch with complete context, Present findings for user decision]
  validation_approach: [Verify all context before dispatch, Validate sub-agent response quality, Confirm fix addresses original issue]

# ─────────────────────────────────────────────────────────────────
# ERROR RECOVERY
# ─────────────────────────────────────────────────────────────────
error_recovery:
  context_incomplete: "Return to Phase 1 to gather missing context"
  report_creation_fails: "Verify template exists, retry with simplified report"
  sub_agent_timeout: "Offer retry with same or different model"
  sub_agent_needs_context: "Gather requested context, re-dispatch"
  fix_application_fails: "Present error, offer manual review option"
  max_retries_exceeded: "Set status to ESCALATE, suggest manual debugging"

# ─────────────────────────────────────────────────────────────────
# RULES
# ─────────────────────────────────────────────────────────────────
rules:
  ALWAYS:
  - verify_context_from_phases
  - create_debug_delegation_md_before_dispatch
  - include_full_context_in_dispatch
  - validate_sub_agent_response
  - check_gate_3_before_applying_fixes_in_adhoc_mode
  - update_debug_delegation_md_with_resolution
  NEVER:
  - dispatch_without_debug_report
  - apply_fixes_without_user_confirmation
  - skip_gate_3_check_in_adhoc_mode
  - exceed_retry_limit_without_escalation
