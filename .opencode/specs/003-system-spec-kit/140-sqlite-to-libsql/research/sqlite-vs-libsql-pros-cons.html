<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SQLite vs libSQL Pros and Cons</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  :root {
    --ve-bg: #f6f7f3;
    --ve-surface: #ffffff;
    --ve-surface-alt: #eef1e8;
    --ve-border: rgba(26, 33, 24, 0.12);
    --ve-border-strong: rgba(26, 33, 24, 0.22);
    --ve-text: #1f271c;
    --ve-text-dim: #5f6958;
    --ve-accent: #0f766e;
    --ve-accent-dim: rgba(15, 118, 110, 0.1);
    --ve-accent-2: #9a3412;
    --ve-shadow: 0 14px 40px rgba(18, 24, 16, 0.08);
    --ve-font-body: 'Bricolage Grotesque', system-ui, sans-serif;
    --ve-font-mono: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --ve-bg: #121713;
      --ve-surface: #1a231b;
      --ve-surface-alt: #212c22;
      --ve-border: rgba(226, 239, 224, 0.12);
      --ve-border-strong: rgba(226, 239, 224, 0.24);
      --ve-text: #e6efe0;
      --ve-text-dim: #a6b8a1;
      --ve-accent: #5eead4;
      --ve-accent-dim: rgba(94, 234, 212, 0.12);
      --ve-accent-2: #fdba74;
      --ve-shadow: 0 16px 44px rgba(0, 0, 0, 0.35);
    }
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    padding: 36px 22px 80px;
    color: var(--ve-text);
    font-family: var(--ve-font-body);
    background:
      radial-gradient(1200px 600px at -10% -10%, var(--ve-accent-dim), transparent 65%),
      radial-gradient(900px 500px at 110% 110%, color-mix(in srgb, var(--ve-accent-2) 16%, transparent), transparent 60%),
      var(--ve-bg);
  }

  .page {
    width: min(1200px, 100%);
    margin: 0 auto;
    display: grid;
    grid-template-columns: 270px minmax(0, 1fr);
    gap: 22px;
    min-width: 0;
  }

  .side,
  .main {
    min-width: 0;
  }

  .panel {
    background: var(--ve-surface);
    border: 1px solid var(--ve-border);
    border-radius: 16px;
    box-shadow: var(--ve-shadow);
  }

  .side {
    position: sticky;
    top: 20px;
    align-self: start;
    padding: 18px;
  }

  .eyebrow {
    font-family: var(--ve-font-mono);
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1.3px;
    color: var(--ve-accent);
    margin-bottom: 8px;
  }

  .doc-title {
    font-size: 20px;
    line-height: 1.22;
    margin: 0 0 8px;
  }

  .doc-meta {
    margin: 0 0 18px;
    color: var(--ve-text-dim);
    font-size: 12px;
    line-height: 1.45;
    font-family: var(--ve-font-mono);
    overflow-wrap: break-word;
  }

  .toc-title {
    font-family: var(--ve-font-mono);
    text-transform: uppercase;
    letter-spacing: 1.1px;
    font-size: 11px;
    color: var(--ve-text-dim);
    margin: 0 0 10px;
  }

  .toc-list {
    list-style: none;
    margin: 0;
    padding: 0;
    display: grid;
    gap: 8px;
  }

  .toc-list a {
    display: block;
    color: var(--ve-text);
    text-decoration: none;
    border: 1px solid var(--ve-border);
    background: var(--ve-surface-alt);
    border-radius: 10px;
    padding: 8px 10px;
    font-size: 12px;
    line-height: 1.35;
    transition: border-color 0.15s ease, background-color 0.15s ease;
    overflow-wrap: break-word;
  }

  .toc-list a:hover {
    border-color: var(--ve-border-strong);
    background: var(--ve-accent-dim);
  }

  .toc-list .toc-h3 {
    margin-left: 12px;
    font-size: 11px;
  }

  .main {
    padding: 28px 34px 34px;
  }

  .hero {
    padding-bottom: 18px;
    border-bottom: 1px solid var(--ve-border);
    margin-bottom: 22px;
  }

  .hero h1 {
    margin: 0 0 10px;
    font-size: clamp(30px, 4vw, 46px);
    line-height: 1.05;
    letter-spacing: -0.02em;
    text-wrap: balance;
  }

  .hero p {
    margin: 0;
    color: var(--ve-text-dim);
    font-family: var(--ve-font-mono);
    font-size: 12px;
    line-height: 1.5;
  }

  .content :is(h1, h2, h3, h4) {
    scroll-margin-top: 24px;
  }

  .content > h1:first-child {
    display: none;
  }

  .content h2 {
    margin: 26px 0 10px;
    font-size: 26px;
    line-height: 1.2;
    border-left: 4px solid var(--ve-accent);
    padding-left: 10px;
  }

  .content h3 {
    margin: 20px 0 8px;
    font-size: 20px;
    line-height: 1.28;
  }

  .content h4 {
    margin: 16px 0 8px;
    font-size: 16px;
    line-height: 1.35;
  }

  .content p {
    margin: 10px 0;
    line-height: 1.72;
    color: var(--ve-text);
    overflow-wrap: break-word;
  }

  .content ul,
  .content ol {
    margin: 8px 0 12px 22px;
    padding: 0;
  }

  .content li {
    margin: 6px 0;
    line-height: 1.6;
    overflow-wrap: break-word;
  }

  .content code {
    font-family: var(--ve-font-mono);
    font-size: 0.86em;
    background: var(--ve-accent-dim);
    color: var(--ve-accent);
    padding: 2px 6px;
    border-radius: 6px;
    overflow-wrap: break-word;
  }

  .content pre {
    background: var(--ve-surface-alt);
    border: 1px solid var(--ve-border);
    border-radius: 12px;
    padding: 14px;
    overflow-x: auto;
  }

  .content pre code {
    background: transparent;
    padding: 0;
    color: inherit;
  }

  .table-scroll {
    margin: 14px 0 18px;
    overflow-x: auto;
    border: 1px solid var(--ve-border);
    border-radius: 12px;
    background: var(--ve-surface);
  }

  .content table {
    width: 100%;
    border-collapse: collapse;
    min-width: 760px;
  }

  .content th,
  .content td {
    vertical-align: top;
    text-align: left;
    padding: 10px 12px;
    border-bottom: 1px solid var(--ve-border);
    line-height: 1.5;
    overflow-wrap: break-word;
  }

  .content thead th {
    position: sticky;
    top: 0;
    z-index: 1;
    background: var(--ve-surface-alt);
    font-family: var(--ve-font-mono);
    font-size: 11px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: var(--ve-text-dim);
  }

  .content tr:last-child td {
    border-bottom: 0;
  }

  .content blockquote {
    margin: 14px 0;
    padding: 10px 14px;
    background: var(--ve-surface-alt);
    border-left: 3px solid var(--ve-accent-2);
    border-radius: 0 10px 10px 0;
  }

  .content a {
    color: var(--ve-accent);
    text-decoration-thickness: 1px;
    text-underline-offset: 2px;
  }

  .content hr {
    border: 0;
    border-top: 1px solid var(--ve-border);
    margin: 24px 0;
  }

  .animate {
    opacity: 0;
    transform: translateY(8px);
    animation: fadeUp 0.36s ease forwards;
    animation-delay: calc(var(--i, 0) * 0.04s);
  }

  @keyframes fadeUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @media (max-width: 980px) {
    .page {
      grid-template-columns: 1fr;
    }
    .side {
      position: static;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      animation-delay: 0ms !important;
      transition-duration: 0.01ms !important;
      animation: none !important;
      transition: none !important;
    }
  }
</style>
</head>
<body>
  <div class="page">
    <aside class="side panel">
      <p class="eyebrow">Visual Explainer</p>
      <h2 class="doc-title">SQLite vs libSQL Pros and Cons</h2>
      <p class="doc-meta">Source: research/sqlite-vs-libsql-pros-cons.md<br>Generated: 20260221-185304</p>
      <h3 class="toc-title">Contents</h3>
      <ul id="toc" class="toc-list"></ul>
    </aside>
    <main class="main panel">
      <header class="hero">
        <h1>SQLite vs libSQL Pros and Cons</h1>
        <p>Source: research/sqlite-vs-libsql-pros-cons.md</p>
      </header>
      <article id="content" class="content">
<h1>SQLite vs libSQL: Feature-Based Decision Comparison</h1>
<p>Audience: Engineering decision-makers
Source validation date: February 21, 2026</p>
<h2>Short summary</h2>
<p>SQLite is the simpler default for local, embedded, single-machine workloads.
libSQL keeps SQLite compatibility for local usage but adds explicit remote/server and replica-oriented capabilities.
The tradeoff is operational: libSQL can support shared/distributed access patterns, but remote operation introduces protocol and consistency semantics you must own.
For most teams, the practical decision boundary is local-only requirements today vs remote/shared requirements now.</p>
<h2>Comparison matrix</h2>
<table>
<thead>
<tr>
<th>Capability</th>
<th>SQLite pros</th>
<th>SQLite cons</th>
<th>libSQL pros</th>
<th>libSQL cons</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Compatibility/API</td>
<td>Stable, widely adopted embedded SQL API and file format.</td>
<td>Does not include libSQL-specific remote protocol surface.</td>
<td>Explicit commitment to SQLite file-format ingest/write and SQLite API compatibility, while allowing additional APIs.</td>
<td>Extra APIs increase compatibility-test surface across clients.</td>
<td>SQLite compatibility statement: <code>context/libsql-main/README.md:126</code>, <code>context/libsql-main/README.md:127</code>. SQLite background: <a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, file format: <a href="https://www2.sqlite.org/fileformat2.html">https://www2.sqlite.org/fileformat2.html</a></td>
</tr>
<tr>
<td>Local embedded usage</td>
<td>In-process, serverless model with low operational overhead.</td>
<td>Limited built-in path for multi-host shared access.</td>
<td>Explicitly remains embeddable and runnable without network connection.</td>
<td>If you only need one local DB file, added libSQL capabilities may be unnecessary complexity.</td>
<td>libSQL embedded stance: <code>context/libsql-main/README.md:128</code>. SQLite embedded/serverless: <a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, usage guidance: <a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a></td>
</tr>
<tr>
<td>Remote/server capabilities</td>
<td>Keeps architecture local and simple by default.</td>
<td>No native built-in server protocol in core SQLite.</td>
<td>Provides server and HTTP v2 protocol (Hrana over HTTP), including sticky routing support via <code>base_url</code>.</td>
<td>Stream baton lifecycle, serialized per-stream request flow, and stream invalidation on HTTP errors add client-state handling complexity.</td>
<td>libSQL server + remote access: <code>context/libsql-main/README.md:46</code>; HTTP v2 semantics: <code>context/libsql-main/docs/HTTP_V2_SPEC.md:1</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:14</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:17</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:24</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:83</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:94</code></td>
</tr>
<tr>
<td>Replication/sync and consistency semantics</td>
<td>Single-node transactional model is straightforward to reason about.</td>
<td>SQLite alone does not define a distributed replica consistency contract.</td>
<td>Documents primary linearizability, read-your-writes (per process), monotonic replica reads, and transaction equivalence to SQLite semantics.</td>
<td>No global ordering guarantee across instances; distinct processes on same replica may observe different points in time.</td>
<td>libSQL consistency model: <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:9</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:13</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:15</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:17</code>. SQLite transaction semantics: <a href="https://sqlite.org/lang_transaction.html">https://sqlite.org/lang_transaction.html</a></td>
</tr>
<tr>
<td>Extensions/vector/FTS</td>
<td>Mature extension loading path and built-in/official FTS5 extension documentation.</td>
<td>Advanced vector/distributed patterns are not a core SQLite concern.</td>
<td>Documents libSQL-specific extensions and feature additions on top of SQLite.</td>
<td>Exact vector/extension availability can vary by deployment/runtime and must be validated per stack.</td>
<td>SQLite extension and FTS docs: <a href="https://www.sqlite.org/loadext.html">https://www.sqlite.org/loadext.html</a>, <a href="https://www.sqlite.org/fts5.html">https://www.sqlite.org/fts5.html</a>. libSQL extension listing: <code>context/libsql-main/README.md:49</code>, <code>context/libsql-main/README.md:57</code></td>
</tr>
<tr>
<td>Operational complexity</td>
<td>Minimal baseline: local file, no network service required.</td>
<td>For shared service behavior, you must add external service architecture yourself.</td>
<td>One technology family can span embedded and server-oriented deployments.</td>
<td>Remote modes require protocol handling, endpoint management, and transaction-shape constraints in stateless APIs.</td>
<td>libSQL embedded + server positioning: <code>context/libsql-main/README.md:46</code>, <code>context/libsql-main/README.md:128</code>; stateless HTTP API constraint: <code>context/libsql-main/docs/http_api.md:49</code></td>
</tr>
<tr>
<td>Performance/latency</td>
<td>Local in-process execution avoids network round-trips.</td>
<td>Cross-host access usually needs added layers and network hops.</td>
<td>Can combine local embedded/replica patterns with remote access when needed.</td>
<td>Remote HTTP/server access adds protocol and network overhead.</td>
<td>I&#39;M UNCERTAIN ABOUT THIS: neither source set provides apples-to-apples benchmark data; this row is architectural inference from local vs remote design. Evidence for remote protocol path: <code>context/libsql-main/docs/HTTP_V2_SPEC.md:3</code>, <code>context/libsql-main/README.md:45</code>, <code>context/libsql-main/README.md:46</code></td>
</tr>
<tr>
<td>Durability/recovery</td>
<td>Mature backup and journaling/WAL documentation with clear local recovery primitives.</td>
<td>SQLite does not itself provide distributed durability orchestration semantics.</td>
<td>Replica model gives an explicit path for shared-service durability designs.</td>
<td>Distributed durability outcomes depend on deployment topology and sync lag behavior.</td>
<td>SQLite durability docs: <a href="https://sqlite.org/backup.html">https://sqlite.org/backup.html</a>, <a href="https://www.sqlite.org/wal.html">https://www.sqlite.org/wal.html</a>. libSQL replica semantics: <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:13</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:17</code></td>
</tr>
<tr>
<td>Ecosystem/tooling</td>
<td>Very broad ecosystem and long operational history.</td>
<td>No built-in remote protocol stack in core project docs.</td>
<td>Official/community drivers and GUI integrations are documented for team workflows.</td>
<td>Tooling maturity can differ by language/driver and should be validated for your runtime.</td>
<td>libSQL drivers and GUI listings: <code>context/libsql-main/README.md:59</code>, <code>context/libsql-main/README.md:61</code>, <code>context/libsql-main/README.md:68</code>, <code>context/libsql-main/README.md:71</code>, <code>context/libsql-main/README.md:77</code></td>
</tr>
</tbody></table>
<h2>Compatibility/API</h2>
<p>Local/embedded distinction: both can run as embedded engines, but libSQL explicitly states ongoing SQLite file-format and SQLite API compatibility while allowing added APIs (<code>context/libsql-main/README.md:126</code>, <code>context/libsql-main/README.md:127</code>, <code>context/libsql-main/README.md:128</code>).
Remote distinction: those additional APIs/protocols are where behavior can diverge operationally, so migration testing should include both local and remote client paths.
SQLite primary references: <a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, <a href="https://www2.sqlite.org/fileformat2.html">https://www2.sqlite.org/fileformat2.html</a></p>
<h2>Local embedded usage</h2>
<p>SQLite is purpose-built for local embedded/serverless use and is generally the lowest-complexity choice when data access remains on one machine (<a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, <a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a>).
libSQL also preserves embedded, in-process usage without requiring a network, so it can be adopted locally first (<code>context/libsql-main/README.md:128</code>).
Decision boundary: if remote/shared access is not a current requirement, SQLite usually minimizes operational work.</p>
<h2>Remote/server capabilities</h2>
<p>SQLite core documentation positions SQLite as an embedded engine rather than a client/server database service (<a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, <a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a>).
libSQL explicitly provides remote server access and an HTTP v2 protocol that exposes stateful streams over HTTP (<code>context/libsql-main/README.md:46</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:1</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:3</code>).
Operational implication: clients must manage baton progression and serialized per-stream requests, and handle stream closure/invalidations (<code>context/libsql-main/docs/HTTP_V2_SPEC.md:14</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:17</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:24</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:94</code>).</p>
<h2>Replication/sync and consistency semantics</h2>
<p>SQLite transactions are ACID with explicit transaction behavior in a single-database context (<a href="https://sqlite.org/lang_transaction.html">https://sqlite.org/lang_transaction.html</a>).
libSQL documents distributed semantics: primary operations are linearizable, a process sees its own writes, replica reads are monotonic, and global ordering is not guaranteed across instances (<code>context/libsql-main/docs/CONSISTENCY_MODEL.md:13</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:15</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:17</code>).
Remote/shared implication: correctness-sensitive features should be designed for per-process guarantees and possible cross-replica observation differences.</p>
<h2>Extensions/vector/FTS</h2>
<p>SQLite provides documented extension loading and FTS5 support (<a href="https://www.sqlite.org/loadext.html">https://www.sqlite.org/loadext.html</a>, <a href="https://www.sqlite.org/fts5.html">https://www.sqlite.org/fts5.html</a>).
libSQL adds documented extensions/improvements on top of SQLite (<code>context/libsql-main/README.md:49</code>, <code>context/libsql-main/README.md:57</code>).
I&#39;M UNCERTAIN ABOUT THIS: vector feature behavior can differ by client/runtime/deployment mode; validate exact capabilities in your target stack before locking architecture.</p>
<h2>Operational complexity</h2>
<p>Local-only operation: SQLite usually has fewer moving parts (single embedded engine, local file model).
Remote/shared operation: libSQL can reduce custom infrastructure work by providing server/protocol primitives, but this shifts complexity into protocol lifecycle and deployment operations (<code>context/libsql-main/README.md:46</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:14</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:24</code>).
Additional constraint: libSQL&#39;s documented stateless HTTP API forbids interactive transactions in that interface (<code>context/libsql-main/docs/http_api.md:49</code>).</p>
<h2>Performance/latency</h2>
<p>Local/embedded path: SQLite (and libSQL in embedded mode) avoids network latency and is typically the baseline for predictable low-latency access.
Remote path: libSQL server/HTTP introduces network and protocol overhead in exchange for shared-access capabilities (<code>context/libsql-main/docs/HTTP_V2_SPEC.md:3</code>, <code>context/libsql-main/README.md:46</code>).
I&#39;M UNCERTAIN ABOUT THIS: no benchmark dataset in the cited sources compares SQLite vs libSQL under identical workload/topology; performance guidance here is design-level, not measured.</p>
<h2>Durability/recovery</h2>
<p>SQLite documents rollback/WAL behavior and backup interfaces for local durability and restore workflows (<a href="https://www.sqlite.org/wal.html">https://www.sqlite.org/wal.html</a>, <a href="https://sqlite.org/backup.html">https://sqlite.org/backup.html</a>).
libSQL remote/replica setups add distributed durability considerations tied to replica synchronization semantics (<code>context/libsql-main/docs/CONSISTENCY_MODEL.md:13</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:17</code>).
Decision implication: choose SQLite for straightforward local recovery models; choose libSQL when shared-service durability requirements justify distributed operational controls.</p>
<h2>Ecosystem/tooling</h2>
<p>SQLite has a large ecosystem and long operational history (<a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, <a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a>).
libSQL documents official/community drivers and GUI integrations, which can help in remote-capable team workflows (<code>context/libsql-main/README.md:59</code>, <code>context/libsql-main/README.md:61</code>, <code>context/libsql-main/README.md:68</code>, <code>context/libsql-main/README.md:71</code>, <code>context/libsql-main/README.md:77</code>).
Selection caveat: validate driver feature parity and protocol support for your production language/runtime.</p>
<h2>Scenario recommendations</h2>
<ul>
<li>single-machine local app: choose SQLite by default; choose libSQL only if near-term remote/replica migration is a concrete requirement.</li>
<li>team/shared service: choose libSQL when multiple clients/services need coordinated remote access and replica semantics.</li>
<li>offline-first: choose SQLite for strictly local-first data; choose libSQL when you need explicit replica/sync semantics beyond one device/process.</li>
<li>cost-sensitive: choose SQLite first for lowest operational footprint; adopt libSQL remote features only when shared/distributed requirements justify added operational spend.</li>
</ul>
<h2>When to choose SQLite</h2>
<ul>
<li>Your primary requirement is local embedded data on one machine/process.</li>
<li>You want the smallest operational surface and no network database service.</li>
<li>Backup/recovery requirements fit local file + WAL/backup workflows.</li>
<li>You do not need built-in distributed consistency semantics today.</li>
</ul>
<h2>When to choose libSQL</h2>
<ul>
<li>You need SQLite compatibility plus built-in remote server/protocol options.</li>
<li>You need documented replica consistency semantics for shared deployments.</li>
<li>You want to keep embedded mode available while adding remote capabilities.</li>
<li>Your team can operate the added protocol/deployment complexity.</li>
</ul>
<h2>References</h2>
<h3>SQLite official (sqlite.org)</h3>
<ul>
<li><a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a></li>
<li><a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a></li>
<li><a href="https://sqlite.org/lang_transaction.html">https://sqlite.org/lang_transaction.html</a></li>
<li><a href="https://www.sqlite.org/wal.html">https://www.sqlite.org/wal.html</a></li>
<li><a href="https://www.sqlite.org/fts5.html">https://www.sqlite.org/fts5.html</a></li>
<li><a href="https://www.sqlite.org/loadext.html">https://www.sqlite.org/loadext.html</a></li>
<li><a href="https://sqlite.org/backup.html">https://sqlite.org/backup.html</a></li>
<li><a href="https://www2.sqlite.org/fileformat2.html">https://www2.sqlite.org/fileformat2.html</a></li>
</ul>
<h3>libSQL local-clone evidence</h3>
<ul>
<li><code>specs/003-system-spec-kit/140-sqlite-to-libsql/context/libsql-main/README.md</code></li>
<li><code>specs/003-system-spec-kit/140-sqlite-to-libsql/context/libsql-main/docs/CONSISTENCY_MODEL.md</code></li>
<li><code>specs/003-system-spec-kit/140-sqlite-to-libsql/context/libsql-main/docs/HTTP_V2_SPEC.md</code></li>
<li><code>specs/003-system-spec-kit/140-sqlite-to-libsql/context/libsql-main/docs/http_api.md</code></li>
</ul>
<h3>Optional Turso/libSQL official web docs</h3>
<ul>
<li><a href="https://turso.tech/libsql">https://turso.tech/libsql</a></li>
<li><a href="https://docs.turso.tech">https://docs.turso.tech</a></li>
</ul>

      </article>
    </main>
  </div>

<script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js"></script>
<script>
(function () {
  const content = document.getElementById('content');
  const toc = document.getElementById('toc');
  if (!content || !toc) return;

  const slugify = (text) => text
    .toLowerCase()
    .replace(/`/g, '')
    .replace(/[^a-z0-9\s-]/g, '')
    .trim()
    .replace(/\s+/g, '-');

  const headings = content.querySelectorAll('h2, h3');
  const seen = new Map();

  headings.forEach((heading) => {
    let id = heading.id || slugify(heading.textContent || 'section');
    const count = seen.get(id) || 0;
    seen.set(id, count + 1);
    if (count > 0) id = `${id}-${count + 1}`;
    heading.id = id;

    const li = document.createElement('li');
    const a = document.createElement('a');
    if (heading.tagName.toLowerCase() === 'h3') a.classList.add('toc-h3');
    a.href = `#${id}`;
    a.textContent = heading.textContent || id;
    li.appendChild(a);
    toc.appendChild(li);
  });

  content.querySelectorAll('table').forEach((table) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'table-scroll';
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);
  });

  content.querySelectorAll('a[href^="http://"], a[href^="https://"]').forEach((a) => {
    a.setAttribute('target', '_blank');
    a.setAttribute('rel', 'noopener noreferrer');
  });

  const animated = content.querySelectorAll('h2, h3, p, ul, ol, blockquote, pre, .table-scroll');
  animated.forEach((el, i) => {
    el.classList.add('animate');
    el.style.setProperty('--i', String(i));
  });
})();
</script>
</body>
</html>
