<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SQLite vs libSQL: Feature-Based Decision Comparison</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Instrument+Serif&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  :root {
    --ve-font-display: 'Instrument Serif', Georgia, serif;
    --ve-font-mono: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
    --ve-bg: #fff5f5;
    --ve-surface: #ffffff;
    --ve-surface-2: #fef0ee;
    --ve-border: rgba(0,0,0,0.08);
    --ve-border-strong: rgba(0,0,0,0.16);
    --ve-text: #201917;
    --ve-text-dim: #7b6f69;
    --ve-accent: #be123c;
    --ve-accent-dim: rgba(190,18,60,0.09);
    --ve-pass: #16a34a;
    --ve-warn: #d97706;
    --ve-gap: #dc2626;
    --ve-shadow: 0 16px 36px rgba(38, 20, 26, 0.08);
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --ve-bg: #1a0d0d;
      --ve-surface: #241616;
      --ve-surface-2: #2f1d1d;
      --ve-border: rgba(255,255,255,0.08);
      --ve-border-strong: rgba(255,255,255,0.16);
      --ve-text: #ffe8e8;
      --ve-text-dim: #c6aaa8;
      --ve-accent: #fb7185;
      --ve-accent-dim: rgba(251,113,133,0.14);
      --ve-pass: #4ade80;
      --ve-warn: #fbbf24;
      --ve-gap: #f87171;
      --ve-shadow: 0 20px 44px rgba(0,0,0,0.35);
    }
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    padding: 34px 20px 72px;
    color: var(--ve-text);
    font-family: system-ui, -apple-system, sans-serif;
    background-color: var(--ve-bg);
    background-image: radial-gradient(1000px 560px at 8% 0%, var(--ve-accent-dim), transparent 64%), radial-gradient(900px 500px at 92% 100%, color-mix(in srgb, var(--ve-pass) 14%, transparent), transparent 62%);
  }

  .wrap {
    width: min(1160px, 100%);
    margin: 0 auto;
    min-width: 0;
  }

  .hero,
  .content {
    background: var(--ve-surface);
    border: 1px solid var(--ve-border);
    border-radius: 12px;
    box-shadow: var(--ve-shadow);
  }

  .hero {
    padding: 24px 26px;
    margin-bottom: 16px;
  }

  .hero h1 {
    margin: 0 0 8px;
    font-family: var(--ve-font-display);
    font-size: clamp(32px, 4vw, 44px);
    font-weight: 400;
    line-height: 1.05;
    letter-spacing: -0.02em;
  }

  .hero p {
    margin: 0;
    font-family: var(--ve-font-mono);
    font-size: 12px;
    color: var(--ve-text-dim);
  }

  .kpi {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 10px;
    margin-top: 14px;
  }

  .kpi .card {
    min-width: 0;
    border: 1px solid var(--ve-border);
    border-radius: 10px;
    background: var(--ve-surface-2);
    padding: 10px 12px;
  }

  .kpi .label {
    margin: 0 0 3px;
    font-family: var(--ve-font-mono);
    font-size: 10px;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: var(--ve-text-dim);
  }

  .kpi .value {
    margin: 0;
    font-size: 22px;
    font-weight: 700;
    line-height: 1.1;
    color: var(--ve-accent);
  }

  .content {
    padding: 20px 24px 26px;
    min-width: 0;
  }

  #content > h1:first-child { display: none; }

  #content h2 {
    margin: 22px 0 10px;
    padding: 7px 11px;
    border-left: 4px solid var(--ve-accent);
    background: var(--ve-surface-2);
    border-radius: 0 8px 8px 0;
    font-size: 24px;
    line-height: 1.2;
  }

  #content h3 {
    margin: 16px 0 8px;
    font-size: 19px;
    line-height: 1.28;
  }

  #content p,
  #content li {
    line-height: 1.72;
    font-size: 14px;
    overflow-wrap: break-word;
  }

  #content ul,
  #content ol {
    margin: 8px 0 12px 22px;
    padding: 0;
  }

  #content code {
    font-family: var(--ve-font-mono);
    background: var(--ve-accent-dim);
    color: var(--ve-accent);
    padding: 2px 6px;
    border-radius: 5px;
    font-size: 0.84em;
  }

  .table-scroll {
    margin: 12px 0 16px;
    border: 1px solid var(--ve-border);
    border-radius: 10px;
    overflow-x: auto;
    background: var(--ve-surface);
  }

  #content table {
    width: 100%;
    border-collapse: collapse;
    min-width: 900px;
  }

  #content th,
  #content td {
    padding: 10px 12px;
    border-bottom: 1px solid var(--ve-border);
    text-align: left;
    vertical-align: top;
    font-size: 13px;
    line-height: 1.55;
    overflow-wrap: break-word;
  }

  #content thead th {
    position: sticky;
    top: 0;
    z-index: 1;
    background: var(--ve-surface-2);
    font-family: var(--ve-font-mono);
    font-size: 10px;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: var(--ve-text-dim);
  }

  #content tr:nth-child(even) td {
    background: color-mix(in srgb, var(--ve-surface) 84%, var(--ve-accent-dim));
  }

  #content tr:last-child td { border-bottom: 0; }

  .status {
    display: inline-flex;
    align-items: center;
    padding: 2px 8px;
    border-radius: 6px;
    font-family: var(--ve-font-mono);
    font-size: 10px;
    font-weight: 600;
    letter-spacing: .3px;
  }

  .status.ok { color: var(--ve-pass); background: color-mix(in srgb, var(--ve-pass) 16%, transparent); }
  .status.warn { color: var(--ve-warn); background: color-mix(in srgb, var(--ve-warn) 16%, transparent); }
  .status.gap { color: var(--ve-gap); background: color-mix(in srgb, var(--ve-gap) 16%, transparent); }

  .anim {
    opacity: 0;
    transform: translateY(8px);
    animation: fadeUp .36s ease forwards;
    animation-delay: calc(var(--i, 0) * 0.04s);
  }

  @keyframes fadeUp {
    to { opacity: 1; transform: translateY(0); }
  }

  @media (max-width: 900px) {
    .kpi { grid-template-columns: 1fr; }
  }

  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      animation-delay: 0ms !important;
      transition-duration: 0.01ms !important;
      animation: none !important;
      transition: none !important;
    }
  }
</style>
</head>
<body>
<div class="wrap">
  <header class="hero">
    <h1>SQLite vs libSQL: Feature-Based Decision Comparison</h1>
    <p>Pros/cons matrix visual | Generated: 2026-02-21 19:18:06</p>
    <div class="kpi" aria-label="document summary">
      <div class="card"><p class="label">Sections</p><p id="kpi-sections" class="value">0</p></div>
      <div class="card"><p class="label">Tables</p><p id="kpi-tables" class="value">0</p></div>
      <div class="card"><p class="label">References</p><p id="kpi-refs" class="value">0</p></div>
    </div>
  </header>

  <main class="content">
    <article id="content">
<h1>SQLite vs libSQL: Feature-Based Decision Comparison</h1>
<p>Audience: Engineering decision-makers
Source validation date: February 21, 2026</p>
<h2>Short summary</h2>
<p>SQLite is the simpler default for local, embedded, single-machine workloads.
libSQL keeps SQLite compatibility for local usage but adds explicit remote/server and replica-oriented capabilities.
The tradeoff is operational: libSQL can support shared/distributed access patterns, but remote operation introduces protocol and consistency semantics you must own.
For most teams, the practical decision boundary is local-only requirements today vs remote/shared requirements now.</p>
<h2>Comparison matrix</h2>
<table>
<thead>
<tr>
<th>Capability</th>
<th>SQLite pros</th>
<th>SQLite cons</th>
<th>libSQL pros</th>
<th>libSQL cons</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Compatibility/API</td>
<td>Stable, widely adopted embedded SQL API and file format.</td>
<td>Does not include libSQL-specific remote protocol surface.</td>
<td>Explicit commitment to SQLite file-format ingest/write and SQLite API compatibility, while allowing additional APIs.</td>
<td>Extra APIs increase compatibility-test surface across clients.</td>
<td>SQLite compatibility statement: <code>context/libsql-main/README.md:126</code>, <code>context/libsql-main/README.md:127</code>. SQLite background: <a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, file format: <a href="https://www2.sqlite.org/fileformat2.html">https://www2.sqlite.org/fileformat2.html</a></td>
</tr>
<tr>
<td>Local embedded usage</td>
<td>In-process, serverless model with low operational overhead.</td>
<td>Limited built-in path for multi-host shared access.</td>
<td>Explicitly remains embeddable and runnable without network connection.</td>
<td>If you only need one local DB file, added libSQL capabilities may be unnecessary complexity.</td>
<td>libSQL embedded stance: <code>context/libsql-main/README.md:128</code>. SQLite embedded/serverless: <a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, usage guidance: <a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a></td>
</tr>
<tr>
<td>Remote/server capabilities</td>
<td>Keeps architecture local and simple by default.</td>
<td>No native built-in server protocol in core SQLite.</td>
<td>Provides server and HTTP v2 protocol (Hrana over HTTP), including sticky routing support via <code>base_url</code>.</td>
<td>Stream baton lifecycle, serialized per-stream request flow, and stream invalidation on HTTP errors add client-state handling complexity.</td>
<td>libSQL server + remote access: <code>context/libsql-main/README.md:46</code>; HTTP v2 semantics: <code>context/libsql-main/docs/HTTP_V2_SPEC.md:1</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:14</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:17</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:24</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:83</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:94</code></td>
</tr>
<tr>
<td>Replication/sync and consistency semantics</td>
<td>Single-node transactional model is straightforward to reason about.</td>
<td>SQLite alone does not define a distributed replica consistency contract.</td>
<td>Documents primary linearizability, read-your-writes (per process), monotonic replica reads, and transaction equivalence to SQLite semantics.</td>
<td>No global ordering guarantee across instances; distinct processes on same replica may observe different points in time.</td>
<td>libSQL consistency model: <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:9</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:13</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:15</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:17</code>. SQLite transaction semantics: <a href="https://sqlite.org/lang_transaction.html">https://sqlite.org/lang_transaction.html</a></td>
</tr>
<tr>
<td>Extensions/vector/FTS</td>
<td>Mature extension loading path and built-in/official FTS5 extension documentation.</td>
<td>Advanced vector/distributed patterns are not a core SQLite concern.</td>
<td>Documents libSQL-specific extensions and feature additions on top of SQLite.</td>
<td>Exact vector/extension availability can vary by deployment/runtime and must be validated per stack.</td>
<td>SQLite extension and FTS docs: <a href="https://www.sqlite.org/loadext.html">https://www.sqlite.org/loadext.html</a>, <a href="https://www.sqlite.org/fts5.html">https://www.sqlite.org/fts5.html</a>. libSQL extension listing: <code>context/libsql-main/README.md:49</code>, <code>context/libsql-main/README.md:57</code></td>
</tr>
<tr>
<td>Operational complexity</td>
<td>Minimal baseline: local file, no network service required.</td>
<td>For shared service behavior, you must add external service architecture yourself.</td>
<td>One technology family can span embedded and server-oriented deployments.</td>
<td>Remote modes require protocol handling, endpoint management, and transaction-shape constraints in stateless APIs.</td>
<td>libSQL embedded + server positioning: <code>context/libsql-main/README.md:46</code>, <code>context/libsql-main/README.md:128</code>; stateless HTTP API constraint: <code>context/libsql-main/docs/http_api.md:49</code></td>
</tr>
<tr>
<td>Performance/latency</td>
<td>Local in-process execution avoids network round-trips.</td>
<td>Cross-host access usually needs added layers and network hops.</td>
<td>Can combine local embedded/replica patterns with remote access when needed.</td>
<td>Remote HTTP/server access adds protocol and network overhead.</td>
<td>I&#39;M UNCERTAIN ABOUT THIS: neither source set provides apples-to-apples benchmark data; this row is architectural inference from local vs remote design. Evidence for remote protocol path: <code>context/libsql-main/docs/HTTP_V2_SPEC.md:3</code>, <code>context/libsql-main/README.md:45</code>, <code>context/libsql-main/README.md:46</code></td>
</tr>
<tr>
<td>Durability/recovery</td>
<td>Mature backup and journaling/WAL documentation with clear local recovery primitives.</td>
<td>SQLite does not itself provide distributed durability orchestration semantics.</td>
<td>Replica model gives an explicit path for shared-service durability designs.</td>
<td>Distributed durability outcomes depend on deployment topology and sync lag behavior.</td>
<td>SQLite durability docs: <a href="https://sqlite.org/backup.html">https://sqlite.org/backup.html</a>, <a href="https://www.sqlite.org/wal.html">https://www.sqlite.org/wal.html</a>. libSQL replica semantics: <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:13</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:17</code></td>
</tr>
<tr>
<td>Ecosystem/tooling</td>
<td>Very broad ecosystem and long operational history.</td>
<td>No built-in remote protocol stack in core project docs.</td>
<td>Official/community drivers and GUI integrations are documented for team workflows.</td>
<td>Tooling maturity can differ by language/driver and should be validated for your runtime.</td>
<td>libSQL drivers and GUI listings: <code>context/libsql-main/README.md:59</code>, <code>context/libsql-main/README.md:61</code>, <code>context/libsql-main/README.md:68</code>, <code>context/libsql-main/README.md:71</code>, <code>context/libsql-main/README.md:77</code></td>
</tr>
</tbody></table>
<h2>Compatibility/API</h2>
<p>Local/embedded distinction: both can run as embedded engines, but libSQL explicitly states ongoing SQLite file-format and SQLite API compatibility while allowing added APIs (<code>context/libsql-main/README.md:126</code>, <code>context/libsql-main/README.md:127</code>, <code>context/libsql-main/README.md:128</code>).
Remote distinction: those additional APIs/protocols are where behavior can diverge operationally, so migration testing should include both local and remote client paths.
SQLite primary references: <a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, <a href="https://www2.sqlite.org/fileformat2.html">https://www2.sqlite.org/fileformat2.html</a></p>
<h2>Local embedded usage</h2>
<p>SQLite is purpose-built for local embedded/serverless use and is generally the lowest-complexity choice when data access remains on one machine (<a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, <a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a>).
libSQL also preserves embedded, in-process usage without requiring a network, so it can be adopted locally first (<code>context/libsql-main/README.md:128</code>).
Decision boundary: if remote/shared access is not a current requirement, SQLite usually minimizes operational work.</p>
<h2>Remote/server capabilities</h2>
<p>SQLite core documentation positions SQLite as an embedded engine rather than a client/server database service (<a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, <a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a>).
libSQL explicitly provides remote server access and an HTTP v2 protocol that exposes stateful streams over HTTP (<code>context/libsql-main/README.md:46</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:1</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:3</code>).
Operational implication: clients must manage baton progression and serialized per-stream requests, and handle stream closure/invalidations (<code>context/libsql-main/docs/HTTP_V2_SPEC.md:14</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:17</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:24</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:94</code>).</p>
<h2>Replication/sync and consistency semantics</h2>
<p>SQLite transactions are ACID with explicit transaction behavior in a single-database context (<a href="https://sqlite.org/lang_transaction.html">https://sqlite.org/lang_transaction.html</a>).
libSQL documents distributed semantics: primary operations are linearizable, a process sees its own writes, replica reads are monotonic, and global ordering is not guaranteed across instances (<code>context/libsql-main/docs/CONSISTENCY_MODEL.md:13</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:15</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:17</code>).
Remote/shared implication: correctness-sensitive features should be designed for per-process guarantees and possible cross-replica observation differences.</p>
<h2>Extensions/vector/FTS</h2>
<p>SQLite provides documented extension loading and FTS5 support (<a href="https://www.sqlite.org/loadext.html">https://www.sqlite.org/loadext.html</a>, <a href="https://www.sqlite.org/fts5.html">https://www.sqlite.org/fts5.html</a>).
libSQL adds documented extensions/improvements on top of SQLite (<code>context/libsql-main/README.md:49</code>, <code>context/libsql-main/README.md:57</code>).
I&#39;M UNCERTAIN ABOUT THIS: vector feature behavior can differ by client/runtime/deployment mode; validate exact capabilities in your target stack before locking architecture.</p>
<h2>Operational complexity</h2>
<p>Local-only operation: SQLite usually has fewer moving parts (single embedded engine, local file model).
Remote/shared operation: libSQL can reduce custom infrastructure work by providing server/protocol primitives, but this shifts complexity into protocol lifecycle and deployment operations (<code>context/libsql-main/README.md:46</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:14</code>, <code>context/libsql-main/docs/HTTP_V2_SPEC.md:24</code>).
Additional constraint: libSQL&#39;s documented stateless HTTP API forbids interactive transactions in that interface (<code>context/libsql-main/docs/http_api.md:49</code>).</p>
<h2>Performance/latency</h2>
<p>Local/embedded path: SQLite (and libSQL in embedded mode) avoids network latency and is typically the baseline for predictable low-latency access.
Remote path: libSQL server/HTTP introduces network and protocol overhead in exchange for shared-access capabilities (<code>context/libsql-main/docs/HTTP_V2_SPEC.md:3</code>, <code>context/libsql-main/README.md:46</code>).
I&#39;M UNCERTAIN ABOUT THIS: no benchmark dataset in the cited sources compares SQLite vs libSQL under identical workload/topology; performance guidance here is design-level, not measured.</p>
<h2>Durability/recovery</h2>
<p>SQLite documents rollback/WAL behavior and backup interfaces for local durability and restore workflows (<a href="https://www.sqlite.org/wal.html">https://www.sqlite.org/wal.html</a>, <a href="https://sqlite.org/backup.html">https://sqlite.org/backup.html</a>).
libSQL remote/replica setups add distributed durability considerations tied to replica synchronization semantics (<code>context/libsql-main/docs/CONSISTENCY_MODEL.md:13</code>, <code>context/libsql-main/docs/CONSISTENCY_MODEL.md:17</code>).
Decision implication: choose SQLite for straightforward local recovery models; choose libSQL when shared-service durability requirements justify distributed operational controls.</p>
<h2>Ecosystem/tooling</h2>
<p>SQLite has a large ecosystem and long operational history (<a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a>, <a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a>).
libSQL documents official/community drivers and GUI integrations, which can help in remote-capable team workflows (<code>context/libsql-main/README.md:59</code>, <code>context/libsql-main/README.md:61</code>, <code>context/libsql-main/README.md:68</code>, <code>context/libsql-main/README.md:71</code>, <code>context/libsql-main/README.md:77</code>).
Selection caveat: validate driver feature parity and protocol support for your production language/runtime.</p>
<h2>Scenario recommendations</h2>
<ul>
<li>single-machine local app: choose SQLite by default; choose libSQL only if near-term remote/replica migration is a concrete requirement.</li>
<li>team/shared service: choose libSQL when multiple clients/services need coordinated remote access and replica semantics.</li>
<li>offline-first: choose SQLite for strictly local-first data; choose libSQL when you need explicit replica/sync semantics beyond one device/process.</li>
<li>cost-sensitive: choose SQLite first for lowest operational footprint; adopt libSQL remote features only when shared/distributed requirements justify added operational spend.</li>
</ul>
<h2>When to choose SQLite</h2>
<ul>
<li>Your primary requirement is local embedded data on one machine/process.</li>
<li>You want the smallest operational surface and no network database service.</li>
<li>Backup/recovery requirements fit local file + WAL/backup workflows.</li>
<li>You do not need built-in distributed consistency semantics today.</li>
</ul>
<h2>When to choose libSQL</h2>
<ul>
<li>You need SQLite compatibility plus built-in remote server/protocol options.</li>
<li>You need documented replica consistency semantics for shared deployments.</li>
<li>You want to keep embedded mode available while adding remote capabilities.</li>
<li>Your team can operate the added protocol/deployment complexity.</li>
</ul>
<h2>References</h2>
<h3>SQLite official (sqlite.org)</h3>
<ul>
<li><a href="https://sqlite.org/about.html">https://sqlite.org/about.html</a></li>
<li><a href="https://sqlite.org/whentouse.html">https://sqlite.org/whentouse.html</a></li>
<li><a href="https://sqlite.org/lang_transaction.html">https://sqlite.org/lang_transaction.html</a></li>
<li><a href="https://www.sqlite.org/wal.html">https://www.sqlite.org/wal.html</a></li>
<li><a href="https://www.sqlite.org/fts5.html">https://www.sqlite.org/fts5.html</a></li>
<li><a href="https://www.sqlite.org/loadext.html">https://www.sqlite.org/loadext.html</a></li>
<li><a href="https://sqlite.org/backup.html">https://sqlite.org/backup.html</a></li>
<li><a href="https://www2.sqlite.org/fileformat2.html">https://www2.sqlite.org/fileformat2.html</a></li>
</ul>
<h3>libSQL local-clone evidence</h3>
<ul>
<li><code>specs/003-system-spec-kit/140-sqlite-to-libsql/context/libsql-main/README.md</code></li>
<li><code>specs/003-system-spec-kit/140-sqlite-to-libsql/context/libsql-main/docs/CONSISTENCY_MODEL.md</code></li>
<li><code>specs/003-system-spec-kit/140-sqlite-to-libsql/context/libsql-main/docs/HTTP_V2_SPEC.md</code></li>
<li><code>specs/003-system-spec-kit/140-sqlite-to-libsql/context/libsql-main/docs/http_api.md</code></li>
</ul>
<h3>Optional Turso/libSQL official web docs</h3>
<ul>
<li><a href="https://turso.tech/libsql">https://turso.tech/libsql</a></li>
<li><a href="https://docs.turso.tech">https://docs.turso.tech</a></li>
</ul>

    </article>
  </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js"></script>
<script>
(function () {
  const content = document.getElementById('content');
  if (!content) return;

  content.querySelectorAll('table').forEach((table) => {
    const wrap = document.createElement('div');
    wrap.className = 'table-scroll';
    table.parentNode.insertBefore(wrap, table);
    wrap.appendChild(table);
  });

  // Lightweight badge mapping for decision-oriented wording in table cells.
  content.querySelectorAll('td').forEach((td) => {
    const text = td.textContent || '';
    if (/\b(choose|default|low risk|pass|compatible|portable)\b/i.test(text)) {
      const badge = document.createElement('span');
      badge.className = 'status ok';
      badge.textContent = 'Strong';
      td.prepend(badge, document.createTextNode(' '));
    } else if (/\b(uncertain|caveat|depends|validate|can vary)\b/i.test(text)) {
      const badge = document.createElement('span');
      badge.className = 'status warn';
      badge.textContent = 'Verify';
      td.prepend(badge, document.createTextNode(' '));
    } else if (/\b(blocker|risk|overhead|not possible|forbidden)\b/i.test(text)) {
      const badge = document.createElement('span');
      badge.className = 'status gap';
      badge.textContent = 'Risk';
      td.prepend(badge, document.createTextNode(' '));
    }
  });

  document.getElementById('kpi-sections').textContent = String(content.querySelectorAll('h2').length);
  document.getElementById('kpi-tables').textContent = String(content.querySelectorAll('table').length);
  document.getElementById('kpi-refs').textContent = String(content.querySelectorAll('a, code').length);

  const targets = content.querySelectorAll('h2, h3, p, ul, ol, .table-scroll, blockquote');
  targets.forEach((el, i) => {
    el.classList.add('anim');
    el.style.setProperty('--i', String(i));
  });
})();
</script>
</body>
</html>
